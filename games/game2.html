<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grid Builder</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    const COLORS = ['blue', 'green', 'red', 'yellow'];
    const TILE_SIZE = 100;
    const GAP = 10;

    // Generate a random puzzle by assigning colors to the 12 edges of a 2x2 grid
    const generatePuzzle = () => {
      // Grid layout (0-indexed):
      //  [0] [1]
      //  [2] [3]
      
      // Each tile has edges: [top, right, bottom, left]
      // We need to assign colors such that shared edges match
      
      const tiles = [
        [null, null, null, null], // tile 0: [top, right, bottom, left]
        [null, null, null, null], // tile 1
        [null, null, null, null], // tile 2
        [null, null, null, null], // tile 3
      ];
      
      // Assign outer edges randomly
      tiles[0][0] = COLORS[Math.floor(Math.random() * 4)]; // top
      tiles[0][3] = COLORS[Math.floor(Math.random() * 4)]; // left
      tiles[1][0] = COLORS[Math.floor(Math.random() * 4)]; // top
      tiles[1][1] = COLORS[Math.floor(Math.random() * 4)]; // right
      tiles[2][2] = COLORS[Math.floor(Math.random() * 4)]; // bottom
      tiles[2][3] = COLORS[Math.floor(Math.random() * 4)]; // left
      tiles[3][1] = COLORS[Math.floor(Math.random() * 4)]; // right
      tiles[3][2] = COLORS[Math.floor(Math.random() * 4)]; // bottom
      
      // Assign shared edges
      const shared01 = COLORS[Math.floor(Math.random() * 4)]; // between tiles 0 and 1 (horizontal)
      tiles[0][1] = shared01;
      tiles[1][3] = shared01;
      
      const shared02 = COLORS[Math.floor(Math.random() * 4)]; // between tiles 0 and 2 (vertical)
      tiles[0][2] = shared02;
      tiles[2][0] = shared02;
      
      const shared13 = COLORS[Math.floor(Math.random() * 4)]; // between tiles 1 and 3 (vertical)
      tiles[1][2] = shared13;
      tiles[3][0] = shared13;
      
      const shared23 = COLORS[Math.floor(Math.random() * 4)]; // between tiles 2 and 3 (horizontal)
      tiles[2][1] = shared23;
      tiles[3][3] = shared23;
      
      return tiles;
    };

    const Tile = ({ edges, size, isDragging }) => {
      if (!edges || edges.length !== 4) return null;
      const [top, right, bottom, left] = edges;
      
      return (
        <div 
          style={{
            width: size,
            height: size,
            position: 'relative',
            background: '#f0f0f0',
            opacity: isDragging ? 0.5 : 1,
            cursor: 'grab',
          }}
        >
          {/* Top edge */}
          <div style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            height: 10,
            background: top,
          }} />
          
          {/* Right edge */}
          <div style={{
            position: 'absolute',
            top: 0,
            right: 0,
            bottom: 0,
            width: 10,
            background: right,
          }} />
          
          {/* Bottom edge */}
          <div style={{
            position: 'absolute',
            bottom: 0,
            left: 0,
            right: 0,
            height: 10,
            background: bottom,
          }} />
          
          {/* Left edge */}
          <div style={{
            position: 'absolute',
            top: 0,
            left: 0,
            bottom: 0,
            width: 10,
            background: left,
          }} />
          
          {/* Black corners */}
          <div style={{
            position: 'absolute',
            top: 0,
            left: 0,
            width: 10,
            height: 10,
            background: 'black',
          }} />
          <div style={{
            position: 'absolute',
            top: 0,
            right: 0,
            width: 10,
            height: 10,
            background: 'black',
          }} />
          <div style={{
            position: 'absolute',
            bottom: 0,
            left: 0,
            width: 10,
            height: 10,
            background: 'black',
          }} />
          <div style={{
            position: 'absolute',
            bottom: 0,
            right: 0,
            width: 10,
            height: 10,
            background: 'black',
          }} />
        </div>
      );
    };

    function GridBuilder() {
      const [solution, setSolution] = useState([]);
      const [grid, setGrid] = useState([null, null, null, null]);
      const [rightSide, setRightSide] = useState([0, 1, 2, 3]);
      const [draggedTile, setDraggedTile] = useState(null);
      const [dragSource, setDragSource] = useState(null);
      const [isComplete, setIsComplete] = useState(false);
      const [lockedTiles, setLockedTiles] = useState([]);
      const [startTime, setStartTime] = useState(null);
      const [elapsedTime, setElapsedTime] = useState(0);
      const [timerInterval, setTimerInterval] = useState(null);
      
      useEffect(() => {
        newGame();
      }, []);
      
      useEffect(() => {
        checkCompletion();
      }, [grid]);

      useEffect(() => {
        // Start timer when game starts
        if (startTime && !isComplete) {
          const interval = setInterval(() => {
            setElapsedTime(Math.floor((Date.now() - startTime) / 1000));
          }, 1000);
          setTimerInterval(interval);
          return () => clearInterval(interval);
        } else if (isComplete && timerInterval) {
          // Stop timer when complete
          clearInterval(timerInterval);
          setTimerInterval(null);
        }
      }, [startTime, isComplete]);
      
      const newGame = () => {
        const newSolution = generatePuzzle();
        setSolution(newSolution);
        setGrid([null, null, null, null]);
        
        // Shuffle tiles for right side
        const shuffled = [0, 1, 2, 3].sort(() => Math.random() - 0.5);
        setRightSide(shuffled);
        setIsComplete(false);
        setLockedTiles([]);
        
        // Start timer
        setStartTime(Date.now());
        setElapsedTime(0);
      };

      const resetGame = () => {
        // Move all tiles back to right side in original order
        const allTiles = [0, 1, 2, 3];
        setRightSide(allTiles);
        setGrid([null, null, null, null]);
        setIsComplete(false);
        setLockedTiles([]);
        
        // Restart timer
        setStartTime(Date.now());
        setElapsedTime(0);
      };

      const quitGame = () => {
        if (confirm('Are you sure you want to quit?')) {
          // Reset to initial state
          newGame();
        }
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const handleHint = () => {
        // Find all empty positions in the grid
        const emptyPositions = [];
        grid.forEach((tile, pos) => {
          if (tile === null) {
            emptyPositions.push(pos);
          }
        });

        if (emptyPositions.length === 0) {
          return; // Grid is full
        }

        // Pick a random empty position
        const randomPos = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
        
        // The correct tile for this position is the tile with index === position
        const correctTile = randomPos;

        // Check if this tile is available (on the right side)
        const tileOnRight = rightSide.includes(correctTile);
        if (!tileOnRight) {
          // Tile is already placed elsewhere, try another position
          const availablePositions = emptyPositions.filter(pos => rightSide.includes(pos));
          if (availablePositions.length === 0) {
            return; // No hints available
          }
          const newPos = availablePositions[Math.floor(Math.random() * availablePositions.length)];
          const newCorrectTile = newPos;
          
          // Place the tile
          const newGrid = [...grid];
          newGrid[newPos] = newCorrectTile;
          setGrid(newGrid);
          
          // Remove from right side
          setRightSide(rightSide.filter(t => t !== newCorrectTile));
          
          // Lock this position
          setLockedTiles([...lockedTiles, newPos]);
        } else {
          // Place the correct tile
          const newGrid = [...grid];
          newGrid[randomPos] = correctTile;
          setGrid(newGrid);
          
          // Remove from right side
          setRightSide(rightSide.filter(t => t !== correctTile));
          
          // Lock this position
          setLockedTiles([...lockedTiles, randomPos]);
        }
      };
      
      const checkCompletion = () => {
        // If all tiles are placed and validation allowed them, it's a win!
        setIsComplete(grid.every(tile => tile !== null));
      };
      
      const validatePlacement = (tileIdx, gridPos, gridToCheck = grid) => {
        const tileEdges = solution[tileIdx];
        const [top, right, bottom, left] = tileEdges;
        
        // Check adjacent tiles
        // Grid layout: [0, 1, 2, 3] => [[0,1], [2,3]]
        
        // Check top neighbor
        if (gridPos >= 2) {
          const topNeighbor = gridToCheck[gridPos - 2];
          if (topNeighbor !== null) {
            const neighborBottom = solution[topNeighbor][2];
            if (top !== neighborBottom) return false;
          }
        }
        
        // Check right neighbor
        if (gridPos % 2 === 0) {
          const rightNeighbor = gridToCheck[gridPos + 1];
          if (rightNeighbor !== null) {
            const neighborLeft = solution[rightNeighbor][3];
            if (right !== neighborLeft) return false;
          }
        }
        
        // Check bottom neighbor
        if (gridPos < 2) {
          const bottomNeighbor = gridToCheck[gridPos + 2];
          if (bottomNeighbor !== null) {
            const neighborTop = solution[bottomNeighbor][0];
            if (bottom !== neighborTop) return false;
          }
        }
        
        // Check left neighbor
        if (gridPos % 2 === 1) {
          const leftNeighbor = gridToCheck[gridPos - 1];
          if (leftNeighbor !== null) {
            const neighborRight = solution[leftNeighbor][1];
            if (left !== neighborRight) return false;
          }
        }
        
        return true;
      };
      
      const handleDragStart = (tileIdx, source) => {
        // Prevent dragging locked tiles
        if (source.type === 'grid' && lockedTiles.includes(source.index)) {
          return;
        }
        setDraggedTile(tileIdx);
        setDragSource(source);
      };
      
      const handleDragEnd = () => {
        setDraggedTile(null);
        setDragSource(null);
      };
      
      const handleDropOnGrid = (gridPos) => {
        if (draggedTile === null) return;
        
        // Check if position is empty
        if (grid[gridPos] !== null) return;
        
        // Create updated grid for validation - clear source position first if moving within grid
        let gridForValidation = [...grid];
        if (dragSource.type === 'grid') {
          gridForValidation[dragSource.index] = null;
        }
        
        // Validate placement using the updated grid
        if (!validatePlacement(draggedTile, gridPos, gridForValidation)) {
          // Return to original position
          return;
        }
        
        // Valid placement - update grid
        const newGrid = [...gridForValidation];
        newGrid[gridPos] = draggedTile;
        setGrid(newGrid);
        
        // Remove from right side if coming from there
        if (dragSource.type === 'right') {
          const newRightSide = rightSide.filter((_, idx) => idx !== dragSource.index);
          setRightSide(newRightSide);
        }
      };
      
      const handleDropOnRight = () => {
        if (draggedTile === null) return;
        if (dragSource.type === 'right') return; // Already on right
        
        // Find original position for this tile
        const originalPos = draggedTile;
        const newRightSide = [...rightSide];
        
        // Insert at correct position to maintain order
        let insertPos = 0;
        for (let i = 0; i < newRightSide.length; i++) {
          if (newRightSide[i] < originalPos) {
            insertPos = i + 1;
          }
        }
        newRightSide.splice(insertPos, 0, draggedTile);
        setRightSide(newRightSide);
        
        // Remove from grid
        if (dragSource.type === 'grid') {
          const newGrid = [...grid];
          newGrid[dragSource.index] = null;
          setGrid(newGrid);
        }
      };
      
      return (
        <div style={{ 
          display: 'flex', 
          justifyContent: 'center', 
          alignItems: 'center', 
          minHeight: '100vh',
          background: '#e8e8e8',
          fontFamily: 'Arial, sans-serif',
          padding: '20px',
        }}>
          {solution.length === 0 ? (
            <div>Loading...</div>
          ) : (
          <div style={{ display: 'flex', gap: '60px', alignItems: 'center' }}>
            {/* Grid */}
            <div>
              <h2 style={{ textAlign: 'center', marginBottom: '10px' }}>Grid Builder</h2>
              <div style={{ 
                textAlign: 'center', 
                marginBottom: '10px',
                fontSize: '24px',
                fontWeight: 'bold',
                color: '#333',
              }}>
                ‚è±Ô∏è {formatTime(elapsedTime)}
              </div>
              <div style={{
                display: 'grid',
                gridTemplateColumns: `repeat(2, ${TILE_SIZE}px)`,
                gridTemplateRows: `repeat(2, ${TILE_SIZE}px)`,
                gap: '0px',
                background: 'white',
                padding: '20px',
                borderRadius: '10px',
                boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
              }}>
                {grid.map((tileIdx, gridPos) => (
                  <div
                    key={gridPos}
                    onDragOver={(e) => e.preventDefault()}
                    onDrop={() => handleDropOnGrid(gridPos)}
                    style={{
                      width: TILE_SIZE,
                      height: TILE_SIZE,
                      background: tileIdx === null ? '#ddd' : 'transparent',
                      borderRadius: '5px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                    }}
                  >
                    {tileIdx !== null && (
                      <div
                        draggable={!lockedTiles.includes(gridPos)}
                        onDragStart={() => handleDragStart(tileIdx, { type: 'grid', index: gridPos })}
                        onDragEnd={handleDragEnd}
                        style={{
                          cursor: lockedTiles.includes(gridPos) ? 'not-allowed' : 'grab',
                          opacity: lockedTiles.includes(gridPos) ? 0.7 : 1,
                          position: 'relative',
                        }}
                      >
                        <Tile 
                          edges={solution[tileIdx]} 
                          size={TILE_SIZE}
                          isDragging={draggedTile === tileIdx}
                        />
                        {lockedTiles.includes(gridPos) && (
                          <div style={{
                            position: 'absolute',
                            top: '50%',
                            left: '50%',
                            transform: 'translate(-50%, -50%)',
                            fontSize: '30px',
                          }}>
                            üîí
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                ))}
              </div>
              
              <div style={{ 
                marginTop: '20px', 
                display: 'flex', 
                gap: '10px',
              }}>
                <button
                  onClick={resetGame}
                  style={{
                    flex: 1,
                    padding: '12px',
                    fontSize: '16px',
                    background: '#2196F3',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  Reset
                </button>
                <button
                  onClick={handleHint}
                  style={{
                    flex: 1,
                    padding: '12px',
                    fontSize: '16px',
                    background: '#FF9800',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  Hint
                </button>
                <button
                  onClick={newGame}
                  style={{
                    flex: 1,
                    padding: '12px',
                    fontSize: '16px',
                    background: '#4CAF50',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  New Game
                </button>
                <button
                  onClick={quitGame}
                  style={{
                    flex: 1,
                    padding: '12px',
                    fontSize: '16px',
                    background: '#f44336',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  Quit
                </button>
              </div>
              
              {isComplete && (
                <div style={{
                  marginTop: '20px',
                  padding: '15px',
                  background: '#4CAF50',
                  color: 'white',
                  textAlign: 'center',
                  borderRadius: '5px',
                  fontSize: '18px',
                  fontWeight: 'bold',
                }}>
                  üéâ You Win! üéâ
                </div>
              )}
            </div>
            
            {/* Right side tiles */}
            <div
              onDragOver={(e) => e.preventDefault()}
              onDrop={handleDropOnRight}
              style={{
                minHeight: '400px',
                minWidth: TILE_SIZE + 40,
              }}
            >
              <h2 style={{ textAlign: 'center', marginBottom: '20px' }}>Tiles</h2>
              <div style={{
                display: 'flex',
                flexDirection: 'column',
                gap: '20px',
                background: 'white',
                padding: '20px',
                borderRadius: '10px',
                boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
              }}>
                {rightSide.map((tileIdx, idx) => (
                  <div
                    key={tileIdx}
                    draggable
                    onDragStart={() => handleDragStart(tileIdx, { type: 'right', index: idx })}
                    onDragEnd={handleDragEnd}
                  >
                    <Tile 
                      edges={solution[tileIdx]} 
                      size={TILE_SIZE}
                      isDragging={draggedTile === tileIdx}
                    />
                  </div>
                ))}
              </div>
            </div>
          </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<GridBuilder />, document.getElementById('root'));
  </script>
</body>
</html>
