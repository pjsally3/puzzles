<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grid Builder</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    const COLORS = ['blue', 'green', 'red', 'yellow'];
    const TILE_SIZE = 80;

    const generatePuzzleForGrid = (rows, cols) => {
      const numTiles = rows * cols;
      const tiles = Array(numTiles).fill(null).map(() => [null, null, null, null]);
      
      for (let i = 0; i < numTiles; i++) {
        const row = Math.floor(i / cols);
        const col = i % cols;
        
        if (row === 0) tiles[i][0] = COLORS[Math.floor(Math.random() * 4)];
        if (col === cols - 1) tiles[i][1] = COLORS[Math.floor(Math.random() * 4)];
        if (row === rows - 1) tiles[i][2] = COLORS[Math.floor(Math.random() * 4)];
        if (col === 0) tiles[i][3] = COLORS[Math.floor(Math.random() * 4)];
      }
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols - 1; col++) {
          const leftIdx = row * cols + col;
          const rightIdx = leftIdx + 1;
          const sharedColor = COLORS[Math.floor(Math.random() * 4)];
          tiles[leftIdx][1] = sharedColor;
          tiles[rightIdx][3] = sharedColor;
        }
      }
      
      for (let row = 0; row < rows - 1; row++) {
        for (let col = 0; col < cols; col++) {
          const topIdx = row * cols + col;
          const bottomIdx = (row + 1) * cols + col;
          const sharedColor = COLORS[Math.floor(Math.random() * 4)];
          tiles[topIdx][2] = sharedColor;
          tiles[bottomIdx][0] = sharedColor;
        }
      }
      
      return tiles;
    };

    const Tile = ({ edges, size, isDragging }) => {
      if (!edges || edges.length !== 4) return null;
      const [top, right, bottom, left] = edges;
      
      return (
        <div 
          style={{
            width: size,
            height: size,
            position: 'relative',
            background: '#f0f0f0',
            opacity: isDragging ? 0.5 : 1,
            cursor: 'grab',
            userSelect: 'none',
            WebkitUserSelect: 'none',
          }}
        >
          <div style={{ position: 'absolute', top: 0, left: 0, right: 0, height: 10, background: top }} />
          <div style={{ position: 'absolute', top: 0, right: 0, bottom: 0, width: 10, background: right }} />
          <div style={{ position: 'absolute', bottom: 0, left: 0, right: 0, height: 10, background: bottom }} />
          <div style={{ position: 'absolute', top: 0, left: 0, bottom: 0, width: 10, background: left }} />
          
          <div style={{ position: 'absolute', top: 0, left: 0, width: 10, height: 10, background: 'black' }} />
          <div style={{ position: 'absolute', top: 0, right: 0, width: 10, height: 10, background: 'black' }} />
          <div style={{ position: 'absolute', bottom: 0, left: 0, width: 10, height: 10, background: 'black' }} />
          <div style={{ position: 'absolute', bottom: 0, right: 0, width: 10, height: 10, background: 'black' }} />
        </div>
      );
    };

    function GridBuilder() {
      const [rows, setRows] = useState(2);
      const [cols, setCols] = useState(2);
      const [activeRows, setActiveRows] = useState(2);
      const [activeCols, setActiveCols] = useState(2);
      const [gameStarted, setGameStarted] = useState(false);
      
      const [solution, setSolution] = useState([]);
      const [grid, setGrid] = useState([]);
      const [rightSide, setRightSide] = useState([]);
      const [tileToPosition, setTileToPosition] = useState({});
      
      const [draggedTile, setDraggedTile] = useState(null);
      const [dragSource, setDragSource] = useState(null);
      const [isComplete, setIsComplete] = useState(false);
      const [lockedTiles, setLockedTiles] = useState([]);
      
      const [startTime, setStartTime] = useState(null);
      const [elapsedTime, setElapsedTime] = useState(0);
      const [timerInterval, setTimerInterval] = useState(null);
      
      useEffect(() => {
        startGame();
      }, []);
      
      useEffect(() => {
        if (grid.length > 0) {
          checkCompletion();
        }
      }, [grid]);

      useEffect(() => {
        if (startTime && !isComplete && gameStarted) {
          const interval = setInterval(() => {
            setElapsedTime(Math.floor((Date.now() - startTime) / 1000));
          }, 1000);
          setTimerInterval(interval);
          return () => clearInterval(interval);
        } else if (isComplete && timerInterval) {
          clearInterval(timerInterval);
          setTimerInterval(null);
        }
      }, [startTime, isComplete, gameStarted]);
      
      const startGame = () => {
        const numTiles = rows * cols;
        const newSolution = generatePuzzleForGrid(rows, cols);
        setSolution(newSolution);
        setGrid(Array(numTiles).fill(null));
        
        // Set active dimensions to current slider values
        setActiveRows(rows);
        setActiveCols(cols);
        
        const allTiles = Array.from({ length: numTiles }, (_, i) => i);
        const shuffled = [...allTiles].sort(() => Math.random() - 0.5);
        const rightSideArray = Array(numTiles).fill(null);
        const positionMap = {};
        shuffled.forEach((tileIdx, displayPos) => {
          rightSideArray[displayPos] = tileIdx;
          positionMap[tileIdx] = displayPos;
        });
        setRightSide(rightSideArray);
        setTileToPosition(positionMap);
        setIsComplete(false);
        setLockedTiles([]);
        setGameStarted(true);
        
        setStartTime(Date.now());
        setElapsedTime(0);
      };

      const newGame = () => {
        setGameStarted(false);
        setGrid([]);
        setRightSide([]);
        setSolution([]);
        setIsComplete(false);
        setLockedTiles([]);
        setTileToPosition({});
        if (timerInterval) {
          clearInterval(timerInterval);
          setTimerInterval(null);
        }
        setElapsedTime(0);
        setStartTime(null);
      };

      const resetGame = () => {
        const numTiles = activeRows * activeCols;
        const allTiles = Array.from({ length: numTiles }, (_, i) => i);
        setRightSide(allTiles);
        
        const positionMap = {};
        allTiles.forEach((tileIdx, pos) => {
          positionMap[tileIdx] = pos;
        });
        setTileToPosition(positionMap);
        
        setGrid(Array(numTiles).fill(null));
        setIsComplete(false);
        setLockedTiles([]);
        
        setStartTime(Date.now());
        setElapsedTime(0);
      };

      const quitGame = () => {
        if (confirm('Are you sure you want to quit?')) {
          setGameStarted(false);
          setGrid([]);
          setRightSide([]);
          setSolution([]);
          setIsComplete(false);
          setLockedTiles([]);
          setTileToPosition({});
          if (timerInterval) {
            clearInterval(timerInterval);
            setTimerInterval(null);
          }
          setElapsedTime(0);
          setStartTime(null);
        }
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const handleHint = () => {
        const emptyPositions = [];
        grid.forEach((tile, pos) => {
          if (tile === null) emptyPositions.push(pos);
        });

        if (emptyPositions.length === 0) return;

        const shuffledPositions = [...emptyPositions].sort(() => Math.random() - 0.5);
        
        for (const pos of shuffledPositions) {
          const correctTile = pos;
          
          if (rightSide.includes(correctTile)) {
            if (validatePlacement(correctTile, pos)) {
              const newGrid = [...grid];
              newGrid[pos] = correctTile;
              setGrid(newGrid);
              
              const rightSideIndex = rightSide.indexOf(correctTile);
              const newRightSide = [...rightSide];
              newRightSide[rightSideIndex] = null;
              setRightSide(newRightSide);
              
              setLockedTiles([...lockedTiles, pos]);
              return;
            }
          }
        }
        
        alert('No valid hints available! Try rearranging your current tiles.');
      };
      
      const checkCompletion = () => {
        setIsComplete(grid.every(tile => tile !== null));
      };
      
      const validatePlacement = (tileIdx, gridPos, gridToCheck = grid) => {
        const tileEdges = solution[tileIdx];
        const [top, right, bottom, left] = tileEdges;
        
        const COLS = activeCols;
        const numTiles = activeRows * activeCols;
        
        if (gridPos >= COLS) {
          const topNeighbor = gridToCheck[gridPos - COLS];
          if (topNeighbor !== null) {
            const neighborBottom = solution[topNeighbor][2];
            if (top !== neighborBottom) return false;
          }
        }
        
        if ((gridPos + 1) % COLS !== 0) {
          const rightNeighbor = gridToCheck[gridPos + 1];
          if (rightNeighbor !== null) {
            const neighborLeft = solution[rightNeighbor][3];
            if (right !== neighborLeft) return false;
          }
        }
        
        if (gridPos < numTiles - COLS) {
          const bottomNeighbor = gridToCheck[gridPos + COLS];
          if (bottomNeighbor !== null) {
            const neighborTop = solution[bottomNeighbor][0];
            if (bottom !== neighborTop) return false;
          }
        }
        
        if (gridPos % COLS !== 0) {
          const leftNeighbor = gridToCheck[gridPos - 1];
          if (leftNeighbor !== null) {
            const neighborRight = solution[leftNeighbor][1];
            if (left !== neighborRight) return false;
          }
        }
        
        return true;
      };
      
      const handleDragStart = (tileIdx, source) => {
        if (source.type === 'grid' && lockedTiles.includes(source.index)) {
          return;
        }
        setDraggedTile(tileIdx);
        setDragSource(source);
      };
      
      const handleDragEnd = () => {
        setDraggedTile(null);
        setDragSource(null);
      };
      
      const handleDropOnGrid = (gridPos) => {
        if (draggedTile === null) return;
        if (grid[gridPos] !== null) return;
        
        let gridForValidation = [...grid];
        if (dragSource.type === 'grid') {
          gridForValidation[dragSource.index] = null;
        }
        
        if (!validatePlacement(draggedTile, gridPos, gridForValidation)) {
          return;
        }
        
        const newGrid = [...gridForValidation];
        newGrid[gridPos] = draggedTile;
        setGrid(newGrid);
        
        if (dragSource.type === 'right') {
          const newRightSide = [...rightSide];
          newRightSide[dragSource.index] = null;
          setRightSide(newRightSide);
        }
      };
      
      const handleDropOnRight = () => {
        if (draggedTile === null) return;
        if (dragSource.type === 'right') return;
        
        const originalPos = tileToPosition[draggedTile];
        if (originalPos === undefined) return;
        
        const newRightSide = [...rightSide];
        newRightSide[originalPos] = draggedTile;
        setRightSide(newRightSide);
        
        if (dragSource.type === 'grid') {
          const newGrid = [...grid];
          newGrid[dragSource.index] = null;
          setGrid(newGrid);
        }
      };
      
      return (
        <div style={{ 
          display: 'flex', 
          justifyContent: 'center', 
          alignItems: 'center', 
          minHeight: '100vh',
          background: '#e8e8e8',
          fontFamily: 'Arial, sans-serif',
          padding: '20px',
        }}>
          <div style={{ display: 'flex', gap: '60px', alignItems: 'center' }}>
            
            <div>
              <h2 style={{ textAlign: 'center', marginBottom: '10px' }}>Grid Builder</h2>
              
              <div style={{
                display: 'flex',
                gap: '20px',
                justifyContent: 'center',
                marginBottom: '10px',
              }}>
                <div style={{ textAlign: 'center' }}>
                  <label style={{ display: 'block', marginBottom: '5px', fontSize: '14px' }}>
                    Rows: {rows}
                  </label>
                  <input
                    type="range"
                    min="2"
                    max="5"
                    value={rows}
                    onChange={(e) => setRows(parseInt(e.target.value))}
                    disabled={gameStarted && !isComplete}
                    style={{ width: '120px' }}
                  />
                </div>
                <div style={{ textAlign: 'center' }}>
                  <label style={{ display: 'block', marginBottom: '5px', fontSize: '14px' }}>
                    Columns: {cols}
                  </label>
                  <input
                    type="range"
                    min="2"
                    max="5"
                    value={cols}
                    onChange={(e) => setCols(parseInt(e.target.value))}
                    disabled={gameStarted && !isComplete}
                    style={{ width: '120px' }}
                  />
                </div>
              </div>
              
              {gameStarted && (
                <div style={{ 
                  textAlign: 'center', 
                  marginBottom: '10px',
                  fontSize: '24px',
                  fontWeight: 'bold',
                  color: '#333',
                }}>
                  ‚è±Ô∏è {formatTime(elapsedTime)}
                </div>
              )}
              
              <div style={{
                display: 'grid',
                gridTemplateColumns: `repeat(${activeCols}, ${TILE_SIZE}px)`,
                gridTemplateRows: `repeat(${activeRows}, ${TILE_SIZE}px)`,
                gap: '0px',
                background: 'white',
                padding: '20px',
                borderRadius: '10px',
                boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
              }}>
                {grid.map((tileIdx, gridPos) => (
                  <div
                    key={gridPos}
                    onDragOver={(e) => e.preventDefault()}
                    onDrop={() => handleDropOnGrid(gridPos)}
                    style={{
                      width: TILE_SIZE,
                      height: TILE_SIZE,
                      background: tileIdx === null ? '#ddd' : 'transparent',
                      borderRadius: '5px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                    }}
                  >
                    {tileIdx !== null && (
                      <div
                        draggable={!lockedTiles.includes(gridPos)}
                        onDragStart={(e) => {
                          handleDragStart(tileIdx, { type: 'grid', index: gridPos });
                          e.dataTransfer.effectAllowed = 'move';
                        }}
                        onDragEnd={handleDragEnd}
                        style={{
                          cursor: lockedTiles.includes(gridPos) ? 'not-allowed' : 'grab',
                          opacity: lockedTiles.includes(gridPos) ? 0.7 : 1,
                          position: 'relative',
                          outline: 'none',
                        }}
                      >
                        <Tile 
                          edges={solution[tileIdx]} 
                          size={TILE_SIZE}
                          isDragging={draggedTile === tileIdx}
                        />
                        {lockedTiles.includes(gridPos) && (
                          <div style={{
                            position: 'absolute',
                            top: '50%',
                            left: '50%',
                            transform: 'translate(-50%, -50%)',
                            fontSize: '30px',
                          }}>
                            üîí
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                ))}
              </div>
              
              <div style={{ 
                marginTop: '20px', 
                display: 'flex', 
                gap: '10px',
              }}>
                <button
                  onClick={startGame}
                  disabled={gameStarted && !isComplete}
                  style={{
                    flex: 1,
                    padding: '12px',
                    fontSize: '16px',
                    background: (gameStarted && !isComplete) ? '#ccc' : '#4CAF50',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: (gameStarted && !isComplete) ? 'not-allowed' : 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  Start
                </button>
                <button
                  onClick={resetGame}
                  disabled={!gameStarted}
                  style={{
                    flex: 1,
                    padding: '12px',
                    fontSize: '16px',
                    background: !gameStarted ? '#ccc' : '#2196F3',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: !gameStarted ? 'not-allowed' : 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  Reset
                </button>
                <button
                  onClick={handleHint}
                  disabled={!gameStarted || isComplete}
                  style={{
                    flex: 1,
                    padding: '12px',
                    fontSize: '16px',
                    background: (!gameStarted || isComplete) ? '#ccc' : '#FF9800',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: (!gameStarted || isComplete) ? 'not-allowed' : 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  Hint
                </button>
                <button
                  onClick={newGame}
                  disabled={!gameStarted}
                  style={{
                    flex: 1,
                    padding: '12px',
                    fontSize: '16px',
                    background: !gameStarted ? '#ccc' : '#4CAF50',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: !gameStarted ? 'not-allowed' : 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  New Game
                </button>
                <button
                  onClick={quitGame}
                  disabled={!gameStarted}
                  style={{
                    flex: 1,
                    padding: '12px',
                    fontSize: '16px',
                    background: !gameStarted ? '#ccc' : '#f44336',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: !gameStarted ? 'not-allowed' : 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  Quit
                </button>
              </div>
            </div>
            
            {isComplete ? (
              <div style={{
                minHeight: '400px',
                minWidth: TILE_SIZE + 40,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}>
                <div style={{
                  padding: '30px',
                  background: '#4CAF50',
                  color: 'white',
                  textAlign: 'center',
                  borderRadius: '10px',
                  fontSize: '24px',
                  fontWeight: 'bold',
                  boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                }}>
                  üéâ You Win! üéâ
                  <div style={{ fontSize: '18px', marginTop: '10px' }}>
                    Time: {formatTime(elapsedTime)}
                  </div>
                </div>
              </div>
            ) : (
              <div
                onDragOver={(e) => e.preventDefault()}
                onDrop={handleDropOnRight}
                style={{
                  minHeight: '400px',
                  minWidth: TILE_SIZE + 40,
                }}
              >
                <h2 style={{ textAlign: 'center', marginBottom: '20px' }}>Tiles</h2>
                <div style={{
                  display: 'flex',
                  gap: '20px',
                  background: 'white',
                  padding: '20px',
                  borderRadius: '10px',
                  boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                }}>
                  {Array.from({ length: Math.ceil((activeRows * activeCols) / 5) }, (_, colIdx) => (
                    <div key={colIdx} style={{
                      display: 'flex',
                      flexDirection: 'column',
                      gap: '20px',
                    }}>
                      {Array.from({ length: 5 }, (_, rowIdx) => {
                        const tilePosition = colIdx * 5 + rowIdx;
                        if (tilePosition >= activeRows * activeCols) return null;
                        
                        const tileIdx = rightSide[tilePosition];
                        
                        if (tileIdx === null) {
                          return (
                            <div
                              key={tilePosition}
                              style={{
                                width: TILE_SIZE,
                                height: TILE_SIZE,
                                background: '#f0f0f0',
                                border: '2px dashed #ccc',
                                borderRadius: '5px',
                              }}
                            />
                          );
                        }
                        
                        return (
                          <div
                            key={tilePosition}
                            draggable
                            onDragStart={() => handleDragStart(tileIdx, { type: 'right', index: tilePosition })}
                            onDragEnd={handleDragEnd}
                          >
                            <Tile 
                              edges={solution[tileIdx]} 
                              size={TILE_SIZE}
                              isDragging={draggedTile === tileIdx}
                            />
                          </div>
                        );
                      })}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<GridBuilder />, document.getElementById('root'));
  </script>
</body>
</html>
