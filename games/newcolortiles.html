<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grid Builder</title>
  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  
  <script src="https://cdn.jsdelivr.net/npm/drag-drop-touch@1.3.1/DragDropTouch.js"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // Initialize Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyD4UVYiRmXS-byupCIJgD4BH2Dq4orkA7w",
      authDomain: "pjpuzzles-4ee57.firebaseapp.com",
      projectId: "pjpuzzles-4ee57",
      storageBucket: "pjpuzzles-4ee57.firebasestorage.app",
      messagingSenderId: "847724129290",
      appId: "1:847724129290:web:e40a80245d1dae0a7103f3",
      measurementId: "G-TVGZ8717SR"
    };
    
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    // Stats helper functions
    const getLocalStats = () => {
      const stats = localStorage.getItem('gridBuilderStats');
      if (!stats) {
        return {
          gamesPlayed: 0,
          gamesWon: 0,
          totalTime: 0,
          bestTime: null,
          statsByDifficulty: {
            easy: { played: 0, won: 0, totalTime: 0, bestTime: null },
            medium: { played: 0, won: 0, totalTime: 0, bestTime: null },
            hard: { played: 0, won: 0, totalTime: 0, bestTime: null },
            extreme: { played: 0, won: 0, totalTime: 0, bestTime: null }
          },
          statsByGridSize: {}
        };
      }
      
      const parsedStats = JSON.parse(stats);
      
      // Migrate old stats to include time fields if missing
      ['easy', 'medium', 'hard', 'extreme'].forEach(diff => {
        if (!parsedStats.statsByDifficulty[diff]) {
          parsedStats.statsByDifficulty[diff] = { played: 0, won: 0, totalTime: 0, bestTime: null };
        } else {
          if (parsedStats.statsByDifficulty[diff].totalTime === undefined) {
            parsedStats.statsByDifficulty[diff].totalTime = 0;
          }
          if (parsedStats.statsByDifficulty[diff].bestTime === undefined) {
            parsedStats.statsByDifficulty[diff].bestTime = null;
          }
        }
      });
      
      return parsedStats;
    };

    const saveLocalStats = (stats) => {
      localStorage.setItem('gridBuilderStats', JSON.stringify(stats));
    };

    const recordGameStart = async (difficulty, gridSize) => {
      // Local stats
      const localStats = getLocalStats();
      localStats.gamesPlayed++;
      localStats.statsByDifficulty[difficulty].played++;
      
      // Initialize grid size stats if needed
      if (!localStats.statsByGridSize[gridSize]) {
        localStats.statsByGridSize[gridSize] = { played: 0, won: 0, totalHints: 0, bestTime: null };
      }
      localStats.statsByGridSize[gridSize].played++;
      
      saveLocalStats(localStats);

      // Global stats
      try {
        await db.collection('stats').add({
          event: 'game_started',
          difficulty: difficulty,
          gridSize: gridSize,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
      } catch (error) {
        console.error('Error recording game start:', error);
      }
    };

    const recordGameWin = async (difficulty, gridSize, timeInSeconds, hintsUsed) => {
      // Local stats
      const localStats = getLocalStats();
      localStats.gamesWon++;
      localStats.totalTime += timeInSeconds;
      localStats.statsByDifficulty[difficulty].won++;
      localStats.statsByDifficulty[difficulty].totalTime += timeInSeconds;
      
      // Update overall best time
      if (localStats.bestTime === null || timeInSeconds < localStats.bestTime) {
        localStats.bestTime = timeInSeconds;
      }
      
      // Update difficulty-specific best time
      if (localStats.statsByDifficulty[difficulty].bestTime === null || 
          timeInSeconds < localStats.statsByDifficulty[difficulty].bestTime) {
        localStats.statsByDifficulty[difficulty].bestTime = timeInSeconds;
      }
      
      // Update grid size stats
      if (!localStats.statsByGridSize[gridSize]) {
        localStats.statsByGridSize[gridSize] = { played: 0, won: 0, totalHints: 0, bestTime: null };
      }
      localStats.statsByGridSize[gridSize].won++;
      localStats.statsByGridSize[gridSize].totalHints += hintsUsed;
      
      if (localStats.statsByGridSize[gridSize].bestTime === null || 
          timeInSeconds < localStats.statsByGridSize[gridSize].bestTime) {
        localStats.statsByGridSize[gridSize].bestTime = timeInSeconds;
      }
      
      saveLocalStats(localStats);

      // Global stats
      try {
        await db.collection('stats').add({
          event: 'game_won',
          difficulty: difficulty,
          gridSize: gridSize,
          timeInSeconds: timeInSeconds,
          hintsUsed: hintsUsed,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
      } catch (error) {
        console.error('Error recording game win:', error);
      }
    };

    const COLORS = ['blue', 'green', 'red', 'yellow'];
    const TILE_SIZE = 60;

    // Difficulty presets with grid configurations
    const DIFFICULTY_PRESETS = {
      easy: [
        { rows: 2, cols: 3, lockPercent: 0.17 },  // 1 locked (was 2)
        { rows: 2, cols: 4, lockPercent: 0.30 },  // 2-3 locked
        { rows: 3, cols: 3, lockPercent: 0.25 },  // 2 locked
      ],
      medium: [
        { rows: 2, cols: 5, lockPercent: 0.25 },  // 2-3 locked
        { rows: 3, cols: 3, lockPercent: 0.15 },  // 1 locked (was 0)
        { rows: 3, cols: 4, lockPercent: 0.20 },  // 2-3 locked
      ],
      hard: [
        { rows: 3, cols: 4, lockPercent: 0.10 },  // 1 locked
        { rows: 3, cols: 5, lockPercent: 0.20 },  // 3 locked
        { rows: 4, cols: 4, lockPercent: 0.20 },  // 3 locked
      ],
      extreme: [
        { rows: 4, cols: 4, lockPercent: 0.05 },  // 0-1 locked
        { rows: 4, cols: 5, lockPercent: 0.08 },  // 1-2 locked
        { rows: 5, cols: 5, lockPercent: 0.10 },  // 2-3 locked
      ]
    };

    const generatePuzzleForGrid = (rows, cols) => {
      const numTiles = rows * cols;
      const tiles = Array(numTiles).fill(null).map(() => [null, null, null, null]);
      
      for (let i = 0; i < numTiles; i++) {
        const row = Math.floor(i / cols);
        const col = i % cols;
        
        if (row === 0) tiles[i][0] = COLORS[Math.floor(Math.random() * 4)];
        if (col === cols - 1) tiles[i][1] = COLORS[Math.floor(Math.random() * 4)];
        if (row === rows - 1) tiles[i][2] = COLORS[Math.floor(Math.random() * 4)];
        if (col === 0) tiles[i][3] = COLORS[Math.floor(Math.random() * 4)];
      }
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols - 1; col++) {
          const leftIdx = row * cols + col;
          const rightIdx = leftIdx + 1;
          const sharedColor = COLORS[Math.floor(Math.random() * 4)];
          tiles[leftIdx][1] = sharedColor;
          tiles[rightIdx][3] = sharedColor;
        }
      }
      
      for (let row = 0; row < rows - 1; row++) {
        for (let col = 0; col < cols; col++) {
          const topIdx = row * cols + col;
          const bottomIdx = (row + 1) * cols + col;
          const sharedColor = COLORS[Math.floor(Math.random() * 4)];
          tiles[topIdx][2] = sharedColor;
          tiles[bottomIdx][0] = sharedColor;
        }
      }
      
      return tiles;
    };

    const Tile = ({ edges, size, isDragging }) => {
      if (!edges || edges.length !== 4) return null;
      const [top, right, bottom, left] = edges;
      
      return (
        <div 
          style={{
            width: size,
            height: size,
            position: 'relative',
            background: '#f0f0f0',
            opacity: isDragging ? 0.5 : 1,
            cursor: 'grab',
            userSelect: 'none',
            WebkitUserSelect: 'none',
          }}
        >
          {/* Top triangle */}
          <svg style={{ position: 'absolute', top: 0, left: 0, width: size, height: size }}>
            <polygon points={`0,0 ${size},0 ${size/2},${size/2}`} fill={top} />
          </svg>
          
          {/* Right triangle */}
          <svg style={{ position: 'absolute', top: 0, left: 0, width: size, height: size }}>
            <polygon points={`${size},0 ${size},${size} ${size/2},${size/2}`} fill={right} />
          </svg>
          
          {/* Bottom triangle */}
          <svg style={{ position: 'absolute', top: 0, left: 0, width: size, height: size }}>
            <polygon points={`0,${size} ${size},${size} ${size/2},${size/2}`} fill={bottom} />
          </svg>
          
          {/* Left triangle */}
          <svg style={{ position: 'absolute', top: 0, left: 0, width: size, height: size }}>
            <polygon points={`0,0 0,${size} ${size/2},${size/2}`} fill={left} />
          </svg>
          
          {/* Black diagonals */}
          <svg style={{ position: 'absolute', top: 0, left: 0, width: size, height: size }}>
            <line x1="0" y1="0" x2={size} y2={size} stroke="black" strokeWidth="2" />
            <line x1={size} y1="0" x2="0" y2={size} stroke="black" strokeWidth="2" />
          </svg>
          
          {/* Black corners - positioned to overlap with adjacent tiles */}
          <div style={{ position: 'absolute', top: -5, left: -5, width: 10, height: 10, background: 'black', borderRadius: '50%' }} />
          <div style={{ position: 'absolute', top: -5, right: -5, width: 10, height: 10, background: 'black', borderRadius: '50%' }} />
          <div style={{ position: 'absolute', bottom: -5, left: -5, width: 10, height: 10, background: 'black', borderRadius: '50%' }} />
          <div style={{ position: 'absolute', bottom: -5, right: -5, width: 10, height: 10, background: 'black', borderRadius: '50%' }} />
        </div>
      );
    };

    function GridBuilder() {
      const [difficulty, setDifficulty] = useState('easy');
      const [activeRows, setActiveRows] = useState(2);
      const [activeCols, setActiveCols] = useState(3);
      const [gameStarted, setGameStarted] = useState(false);
      
      const [solution, setSolution] = useState([]);
      const [grid, setGrid] = useState([]);
      const [rightSide, setRightSide] = useState([]);
      const [tileToPosition, setTileToPosition] = useState({});
      
      const [draggedTile, setDraggedTile] = useState(null);
      const [dragSource, setDragSource] = useState(null);
      const [isComplete, setIsComplete] = useState(false);
      const [lockedTiles, setLockedTiles] = useState([]);
      
      const [startTime, setStartTime] = useState(null);
      const [elapsedTime, setElapsedTime] = useState(0);
      const [timerInterval, setTimerInterval] = useState(null);
      const [showHowToPlay, setShowHowToPlay] = useState(false);
      const [showStats, setShowStats] = useState(false);
      const [globalStats, setGlobalStats] = useState(null);
      const [hintsUsed, setHintsUsed] = useState(0);
      const [lastConfig, setLastConfig] = useState(null); // Track last configuration used
      const [hasBookmark, setHasBookmark] = useState(false); // Track if bookmark exists
      
      const calculateEdgeCounts = () => {
        const counts = {
          top: { blue: 0, green: 0, red: 0, yellow: 0 },
          right: { blue: 0, green: 0, red: 0, yellow: 0 },
          bottom: { blue: 0, green: 0, red: 0, yellow: 0 },
          left: { blue: 0, green: 0, red: 0, yellow: 0 },
        };
        
        // Count edges from unused tiles (tiles still on right side)
        rightSide.forEach(tileIdx => {
          if (tileIdx !== null && solution[tileIdx]) {
            const [top, right, bottom, left] = solution[tileIdx];
            counts.top[top]++;
            counts.right[right]++;
            counts.bottom[bottom]++;
            counts.left[left]++;
          }
        });
        
        return counts;
      };
      
      useEffect(() => {
        // Don't auto-start anymore - let user configure first
        // Check for existing bookmark
        const bookmark = localStorage.getItem('gridBuilderBookmark');
        setHasBookmark(!!bookmark);
      }, []);
      
      useEffect(() => {
        if (grid.length > 0) {
          checkCompletion();
        }
      }, [grid]);

      useEffect(() => {
        if (startTime && !isComplete && gameStarted) {
          const interval = setInterval(() => {
            setElapsedTime(Math.floor((Date.now() - startTime) / 1000));
          }, 1000);
          setTimerInterval(interval);
          return () => clearInterval(interval);
        } else if (isComplete && timerInterval) {
          clearInterval(timerInterval);
          setTimerInterval(null);
        }
      }, [startTime, isComplete, gameStarted]);
      
      const startGame = () => {
        // Select random preset for chosen difficulty, avoiding last config if possible
        const presets = DIFFICULTY_PRESETS[difficulty];
        let preset;
        
        if (presets.length > 1 && lastConfig && lastConfig.difficulty === difficulty) {
          // Filter out the last configuration
          const availablePresets = presets.filter(p => 
            !(p.rows === lastConfig.rows && p.cols === lastConfig.cols)
          );
          // If we have other options, use them; otherwise use any preset
          const presetsToChooseFrom = availablePresets.length > 0 ? availablePresets : presets;
          preset = presetsToChooseFrom[Math.floor(Math.random() * presetsToChooseFrom.length)];
        } else {
          // First game or difficulty changed, pick any preset
          preset = presets[Math.floor(Math.random() * presets.length)];
        }
        
        const { rows, cols, lockPercent } = preset;
        
        // Save this configuration for next time
        setLastConfig({ difficulty, rows, cols });
        
        const numTiles = rows * cols;
        const newSolution = generatePuzzleForGrid(rows, cols);
        setSolution(newSolution);
        
        // Calculate number of hint tiles based on preset
        let numHints = Math.floor(numTiles * lockPercent);
        
        // Initialize grid and right side (always 25 spaces)
        const newGrid = Array(numTiles).fill(null);
        const allTiles = Array.from({ length: numTiles }, (_, i) => i);
        const shuffled = [...allTiles].sort(() => Math.random() - 0.5);
        const rightSideArray = Array(25).fill(null); // Always 25 spaces
        const positionMap = {};
        shuffled.forEach((tileIdx, idx) => {
          rightSideArray[idx] = tileIdx;
          positionMap[tileIdx] = idx;
        });
        
        // Place hint tiles randomly
        const newLockedTiles = [];
        const availablePositions = [...allTiles];
        
        for (let i = 0; i < numHints; i++) {
          if (availablePositions.length === 0) break;
          
          const randomIndex = Math.floor(Math.random() * availablePositions.length);
          const pos = availablePositions.splice(randomIndex, 1)[0];
          
          const correctTile = pos; // tile index equals position
          newGrid[pos] = correctTile;
          rightSideArray[positionMap[correctTile]] = null;
          newLockedTiles.push(pos);
        }
        
        setGrid(newGrid);
        setRightSide(rightSideArray);
        setTileToPosition(positionMap);
        setIsComplete(false);
        setLockedTiles(newLockedTiles);
        
        // Set active dimensions
        setActiveRows(rows);
        setActiveCols(cols);
        setGameStarted(true);
        
        setStartTime(Date.now());
        setElapsedTime(0);
        setHintsUsed(0);
        
        // Record game start
        recordGameStart(difficulty, `${rows}x${cols}`);
      };

      const resetGame = () => {
        const numTiles = activeRows * activeCols;
        
        // Build new grid preserving locked tiles
        const newGrid = Array(numTiles).fill(null);
        lockedTiles.forEach(pos => {
          newGrid[pos] = grid[pos]; // Keep the locked tile in place
        });
        
        // Build right side with all non-locked tiles
        const allTiles = Array.from({ length: numTiles }, (_, i) => i);
        const availableTiles = allTiles.filter(tile => !lockedTiles.includes(tile));
        
        const rightSideArray = Array(numTiles).fill(null);
        const positionMap = {};
        
        // Place available tiles in their original positions on right side
        availableTiles.forEach((tileIdx, idx) => {
          rightSideArray[tileIdx] = tileIdx;
          positionMap[tileIdx] = tileIdx;
        });
        
        // Keep position map for locked tiles too
        lockedTiles.forEach(pos => {
          positionMap[pos] = pos;
        });
        
        setGrid(newGrid);
        setRightSide(rightSideArray);
        setTileToPosition(positionMap);
        setIsComplete(false);
        // Keep lockedTiles unchanged
        // Do NOT restart timer - let it continue
      };

      const quitGame = () => {
        if (confirm('Are you sure you want to quit?')) {
          setGameStarted(false);
          setGrid([]);
          setRightSide([]);
          setSolution([]);
          setIsComplete(false);
          setLockedTiles([]);
          setTileToPosition({});
          if (timerInterval) {
            clearInterval(timerInterval);
            setTimerInterval(null);
          }
          setElapsedTime(0);
          setStartTime(null);
        }
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const fetchGlobalStats = async () => {
        try {
          const gamesStarted = await db.collection('stats').where('event', '==', 'game_started').get();
          const gamesWon = await db.collection('stats').where('event', '==', 'game_won').get();
          
          let totalTime = 0;
          let gameCount = 0;
          
          gamesWon.forEach(doc => {
            const data = doc.data();
            if (data.timeInSeconds) {
              totalTime += data.timeInSeconds;
              gameCount++;
            }
          });
          
          const avgTime = gameCount > 0 ? Math.round(totalTime / gameCount) : 0;
          
          return {
            totalGamesStarted: gamesStarted.size,
            totalGamesWon: gamesWon.size,
            averageTime: avgTime
          };
        } catch (error) {
          console.error('Error fetching global stats:', error);
          return null;
        }
      };

      const openStatsDialog = async () => {
        setShowStats(true);
        const stats = await fetchGlobalStats();
        setGlobalStats(stats);
      };

      const saveBookmark = () => {
        if (!gameStarted) {
          alert('No game in progress to bookmark!');
          return;
        }

        const bookmark = {
          difficulty,
          activeRows,
          activeCols,
          solution,
          grid,
          rightSide,
          tileToPosition,
          lockedTiles,
          elapsedTime,
          hintsUsed,
          isComplete,
          timestamp: Date.now()
        };

        localStorage.setItem('gridBuilderBookmark', JSON.stringify(bookmark));
        setHasBookmark(true);
        // No alert - silent save
      };

      const useBookmark = () => {
        const bookmarkData = localStorage.getItem('gridBuilderBookmark');
        if (!bookmarkData) {
          alert('No bookmark found!');
          return;
        }

        // Confirm BEFORE restoring
        if (gameStarted && !confirm('Restore bookmarked game? This will replace your current game.')) {
          return;
        }

        try {
          const bookmark = JSON.parse(bookmarkData);
          
          // Restore all game state
          setDifficulty(bookmark.difficulty);
          setActiveRows(bookmark.activeRows);
          setActiveCols(bookmark.activeCols);
          setSolution(bookmark.solution);
          setGrid(bookmark.grid);
          setRightSide(bookmark.rightSide);
          setTileToPosition(bookmark.tileToPosition);
          setLockedTiles(bookmark.lockedTiles);
          setElapsedTime(bookmark.elapsedTime);
          setHintsUsed(bookmark.hintsUsed);
          setIsComplete(bookmark.isComplete);
          setGameStarted(true);
          
          // Restart timer from bookmarked time
          setStartTime(Date.now() - (bookmark.elapsedTime * 1000));
          
          // No alert after - user can see it worked
        } catch (error) {
          console.error('Error restoring bookmark:', error);
          alert('Error restoring bookmark. It may be corrupted.');
        }
      };

      const handleHint = () => {
        const emptyPositions = [];
        grid.forEach((tile, pos) => {
          if (tile === null) emptyPositions.push(pos);
        });

        if (emptyPositions.length === 0) return;

        const shuffledPositions = [...emptyPositions].sort(() => Math.random() - 0.5);
        
        for (const pos of shuffledPositions) {
          const correctTile = pos;
          
          if (rightSide.includes(correctTile)) {
            if (validatePlacement(correctTile, pos)) {
              const newGrid = [...grid];
              newGrid[pos] = correctTile;
              setGrid(newGrid);
              
              const rightSideIndex = rightSide.indexOf(correctTile);
              const newRightSide = [...rightSide];
              newRightSide[rightSideIndex] = null;
              setRightSide(newRightSide);
              
              setLockedTiles([...lockedTiles, pos]);
              setHintsUsed(hintsUsed + 1); // Increment hints counter
              return;
            }
          }
        }
        
        alert('No valid hints available! Try rearranging your current tiles.');
      };
      
      const checkCompletion = () => {
        const wasComplete = isComplete;
        const nowComplete = grid.every(tile => tile !== null);
        setIsComplete(nowComplete);
        
        // If just completed, record win
        if (!wasComplete && nowComplete) {
          recordGameWin(difficulty, `${activeRows}x${activeCols}`, elapsedTime, hintsUsed);
        }
      };
      
      const validatePlacement = (tileIdx, gridPos, gridToCheck = grid) => {
        const tileEdges = solution[tileIdx];
        const [top, right, bottom, left] = tileEdges;
        
        const COLS = activeCols;
        const numTiles = activeRows * activeCols;
        
        if (gridPos >= COLS) {
          const topNeighbor = gridToCheck[gridPos - COLS];
          if (topNeighbor !== null) {
            const neighborBottom = solution[topNeighbor][2];
            if (top !== neighborBottom) return false;
          }
        }
        
        if ((gridPos + 1) % COLS !== 0) {
          const rightNeighbor = gridToCheck[gridPos + 1];
          if (rightNeighbor !== null) {
            const neighborLeft = solution[rightNeighbor][3];
            if (right !== neighborLeft) return false;
          }
        }
        
        if (gridPos < numTiles - COLS) {
          const bottomNeighbor = gridToCheck[gridPos + COLS];
          if (bottomNeighbor !== null) {
            const neighborTop = solution[bottomNeighbor][0];
            if (bottom !== neighborTop) return false;
          }
        }
        
        if (gridPos % COLS !== 0) {
          const leftNeighbor = gridToCheck[gridPos - 1];
          if (leftNeighbor !== null) {
            const neighborRight = solution[leftNeighbor][1];
            if (left !== neighborRight) return false;
          }
        }
        
        return true;
      };
      
      const handleDragStart = (tileIdx, source) => {
        if (source.type === 'grid' && lockedTiles.includes(source.index)) {
          return;
        }
        setDraggedTile(tileIdx);
        setDragSource(source);
      };
      
      const handleDragEnd = () => {
        setDraggedTile(null);
        setDragSource(null);
      };
      
      const handleDropOnGrid = (gridPos) => {
        if (draggedTile === null) return;
        if (grid[gridPos] !== null) return;
        
        let gridForValidation = [...grid];
        if (dragSource.type === 'grid') {
          gridForValidation[dragSource.index] = null;
        }
        
        if (!validatePlacement(draggedTile, gridPos, gridForValidation)) {
          return;
        }
        
        const newGrid = [...gridForValidation];
        newGrid[gridPos] = draggedTile;
        setGrid(newGrid);
        
        if (dragSource.type === 'right') {
          const newRightSide = [...rightSide];
          newRightSide[dragSource.index] = null;
          setRightSide(newRightSide);
        }
      };
      
      const handleDropOnRight = (targetPosition) => {
        if (draggedTile === null) return;
        
        if (dragSource.type === 'right') {
          // Moving within right side - swap positions
          const newRightSide = [...rightSide];
          const sourceTile = newRightSide[dragSource.index];
          const targetTile = newRightSide[targetPosition];
          
          newRightSide[dragSource.index] = targetTile;
          newRightSide[targetPosition] = sourceTile;
          
          // Update position map
          const newTileToPosition = { ...tileToPosition };
          if (sourceTile !== null) newTileToPosition[sourceTile] = targetPosition;
          if (targetTile !== null) newTileToPosition[targetTile] = dragSource.index;
          
          setRightSide(newRightSide);
          setTileToPosition(newTileToPosition);
          return;
        }
        
        // Coming from grid - place in target position (if empty) or find first empty spot
        const originalPosition = tileToPosition[draggedTile];
        let finalPosition = targetPosition;
        
        // If target is occupied, try to find an empty spot
        if (rightSide[targetPosition] !== null) {
          // First try the original position
          if (originalPosition !== undefined && rightSide[originalPosition] === null) {
            finalPosition = originalPosition;
          } else {
            // Find first empty spot
            const emptySpot = rightSide.findIndex(tile => tile === null);
            if (emptySpot !== -1) {
              finalPosition = emptySpot;
            } else {
              // No empty spots - shouldn't happen but use original position as fallback
              finalPosition = originalPosition !== undefined ? originalPosition : targetPosition;
            }
          }
        }
        
        const newRightSide = [...rightSide];
        newRightSide[finalPosition] = draggedTile;
        setRightSide(newRightSide);
        
        // Update position map
        const newTileToPosition = { ...tileToPosition };
        newTileToPosition[draggedTile] = finalPosition;
        setTileToPosition(newTileToPosition);
        
        if (dragSource.type === 'grid') {
          const newGrid = [...grid];
          newGrid[dragSource.index] = null;
          setGrid(newGrid);
        }
      };
      
      return (
        <div style={{ 
          display: 'flex', 
          justifyContent: 'center', 
          alignItems: 'center', 
          minHeight: '100vh',
          background: '#e8e8e8',
          fontFamily: 'Arial, sans-serif',
          padding: '10px',
        }}>
          <div style={{ display: 'flex', gap: '30px', alignItems: 'flex-start' }}>
            
            <div>
              <h2 style={{ textAlign: 'center', marginBottom: '5px', fontSize: '18px' }}>Grid Builder</h2>
              
              <div style={{
                display: 'flex',
                gap: '10px',
                justifyContent: 'center',
                marginBottom: '5px',
              }}>
                {['easy', 'medium', 'hard', 'extreme'].map(level => (
                  <button
                    key={level}
                    onClick={() => setDifficulty(level)}
                    disabled={gameStarted && !isComplete}
                    style={{
                      flex: 1,
                      padding: '8px 12px',
                      fontSize: '13px',
                      background: difficulty === level 
                        ? (gameStarted && !isComplete ? '#ccc' : '#4CAF50')
                        : (gameStarted && !isComplete ? '#ddd' : '#f0f0f0'),
                      color: difficulty === level ? 'white' : '#333',
                      border: difficulty === level ? '2px solid #2E7D32' : '2px solid #ccc',
                      borderRadius: '5px',
                      cursor: (gameStarted && !isComplete) ? 'not-allowed' : 'pointer',
                      fontWeight: difficulty === level ? 'bold' : 'normal',
                      textTransform: 'capitalize',
                    }}
                  >
                    {level}
                  </button>
                ))}
              </div>
              
              {gameStarted && (
                <div style={{ 
                  textAlign: 'center', 
                  marginBottom: '5px',
                  fontSize: '18px',
                  fontWeight: 'bold',
                  color: '#333',
                }}>
                  ‚è±Ô∏è {formatTime(elapsedTime)}
                </div>
              )}
              
              <div style={{
                display: 'grid',
                gridTemplateColumns: `repeat(${activeCols}, ${TILE_SIZE}px)`,
                gridTemplateRows: `repeat(${activeRows}, ${TILE_SIZE}px)`,
                gap: '0px',
                background: 'white',
                padding: '10px',
                borderRadius: '8px',
                boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
              }}>
                {grid.map((tileIdx, gridPos) => (
                  <div
                    key={gridPos}
                    onDragOver={(e) => e.preventDefault()}
                    onDrop={() => handleDropOnGrid(gridPos)}
                    style={{
                      width: TILE_SIZE,
                      height: TILE_SIZE,
                      background: tileIdx === null ? '#ddd' : 'transparent',
                      borderRadius: '3px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                    }}
                  >
                    {tileIdx !== null && (
                      <div
                        draggable={!lockedTiles.includes(gridPos)}
                        onDragStart={(e) => {
                          handleDragStart(tileIdx, { type: 'grid', index: gridPos });
                          e.dataTransfer.effectAllowed = 'move';
                        }}
                        onDragEnd={handleDragEnd}
                        style={{
                          cursor: lockedTiles.includes(gridPos) ? 'not-allowed' : 'grab',
                          opacity: lockedTiles.includes(gridPos) ? 0.7 : 1,
                          position: 'relative',
                          outline: 'none',
                        }}
                      >
                        <Tile 
                          edges={solution[tileIdx]} 
                          size={TILE_SIZE}
                          isDragging={draggedTile === tileIdx}
                        />
                        {lockedTiles.includes(gridPos) && (
                          <div style={{
                            position: 'absolute',
                            top: '50%',
                            left: '50%',
                            transform: 'translate(-50%, -50%)',
                            fontSize: '24px',
                          }}>
                            üîí
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                ))}
              </div>
              
              <div style={{ 
                marginTop: '10px',
              }}>
                {/* First row: New Game, Clear, Hint, Quit */}
                <div style={{
                  display: 'flex',
                  gap: '8px',
                  marginBottom: '8px',
                }}>
                  <button
                    onClick={startGame}
                    style={{
                      flex: 1,
                      padding: '8px',
                      fontSize: '13px',
                      background: '#4CAF50',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    {gameStarted ? 'New Game' : 'Start Game'}
                  </button>
                  <button
                    onClick={resetGame}
                    disabled={!gameStarted}
                    style={{
                      flex: 1,
                      padding: '8px',
                      fontSize: '13px',
                      background: !gameStarted ? '#ccc' : '#2196F3',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: !gameStarted ? 'not-allowed' : 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    Clear
                  </button>
                  <button
                    onClick={handleHint}
                    disabled={!gameStarted || isComplete}
                    style={{
                      flex: 1,
                      padding: '8px',
                      fontSize: '13px',
                      background: (!gameStarted || isComplete) ? '#ccc' : '#FF9800',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: (!gameStarted || isComplete) ? 'not-allowed' : 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    Hint
                  </button>
                  <button
                    onClick={quitGame}
                    disabled={!gameStarted}
                    style={{
                      flex: 1,
                      padding: '8px',
                      fontSize: '13px',
                      background: !gameStarted ? '#ccc' : '#f44336',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: !gameStarted ? 'not-allowed' : 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    Quit
                  </button>
                </div>
                
                {/* Second row: How To Play, Stats, Clear Stats, Bookmark, Use Bookmark */}
                <div style={{
                  display: 'flex',
                  gap: '8px',
                }}>
                  <button
                    onClick={() => setShowHowToPlay(true)}
                    style={{
                      flex: 1,
                      padding: '8px',
                      fontSize: '13px',
                      background: '#9C27B0',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    How To Play
                  </button>
                  <button
                    onClick={openStatsDialog}
                    style={{
                      flex: 1,
                      padding: '8px',
                      fontSize: '13px',
                      background: '#00BCD4',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    Stats
                  </button>
                  <button
                    onClick={() => {
                      if (confirm('Are you sure you want to clear all stats? This cannot be undone.')) {
                        localStorage.removeItem('gridBuilderStats');
                        alert('All stats have been cleared!');
                      }
                    }}
                    style={{
                      flex: 1,
                      padding: '8px',
                      fontSize: '13px',
                      background: '#795548',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    Clear Stats
                  </button>
                  <button
                    onClick={saveBookmark}
                    disabled={!gameStarted}
                    style={{
                      flex: 1,
                      padding: '8px',
                      fontSize: '13px',
                      background: !gameStarted ? '#ccc' : '#673AB7',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: !gameStarted ? 'not-allowed' : 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    Bookmark
                  </button>
                  <button
                    onClick={useBookmark}
                    disabled={!hasBookmark}
                    style={{
                      flex: 1,
                      padding: '8px',
                      fontSize: '13px',
                      background: !hasBookmark ? '#ccc' : '#E91E63',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: !hasBookmark ? 'not-allowed' : 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    Go Back to Bookmark
                  </button>
                </div>
              </div>
            </div>
            
            {isComplete ? (
              <div style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'rgba(0,0,0,0.85)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 999,
              }}>
                <div style={{
                  background: 'linear-gradient(135deg, #ffffff 0%, #f0f9ff 100%)',
                  padding: '30px',
                  borderRadius: '15px',
                  textAlign: 'center',
                  maxWidth: '500px',
                  boxShadow: '0 10px 40px rgba(0,0,0,0.4)',
                  border: '3px solid #4CAF50',
                }}>
                  <div style={{
                    fontSize: '48px',
                    marginBottom: '5px',
                  }}>
                    üèÜ
                  </div>
                  <h1 style={{
                    margin: '0 0 3px 0',
                    color: '#2E7D32',
                    fontSize: '36px',
                    fontWeight: 'bold',
                    textShadow: '2px 2px 4px rgba(0,0,0,0.1)',
                  }}>
                    VICTORY!
                  </h1>
                  
                  <div style={{
                    background: (() => {
                      const colors = {
                        easy: '#4CAF50',
                        medium: '#FF9800',
                        hard: '#FF5722',
                        extreme: '#9C27B0'
                      };
                      return colors[difficulty];
                    })(),
                    color: 'white',
                    padding: '8px 16px',
                    borderRadius: '20px',
                    fontSize: '16px',
                    fontWeight: 'bold',
                    margin: '15px auto',
                    textTransform: 'capitalize',
                    display: 'inline-block',
                  }}>
                    {difficulty} ‚Ä¢ {activeRows}√ó{activeCols} ‚Ä¢ {formatTime(elapsedTime)}
                  </div>
                  
                  {(() => {
                    const localStats = getLocalStats();
                    const diffStats = localStats.statsByDifficulty[difficulty];
                    const winRate = diffStats.played > 0 ? Math.round((diffStats.won / diffStats.played) * 100) : 0;
                    const diffAvgTime = diffStats.won > 0 ? Math.round(diffStats.totalTime / diffStats.won) : 0;
                    
                    return (
                      <div style={{
                        background: 'white',
                        padding: '20px',
                        borderRadius: '10px',
                        marginBottom: '15px',
                        textAlign: 'left',
                        boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
                      }}>
                        {/* Difficulty Stats */}
                        <h3 style={{ 
                          marginTop: 0, 
                          marginBottom: '12px', 
                          textAlign: 'center',
                          fontSize: '16px',
                          color: '#333',
                          textTransform: 'capitalize',
                        }}>
                          {difficulty} Level Stats
                        </h3>
                        <div style={{ 
                          display: 'grid',
                          gridTemplateColumns: '1fr 1fr 1fr',
                          gap: '8px',
                          marginBottom: '15px',
                        }}>
                          <div style={{ background: '#f5f5f5', padding: '8px', borderRadius: '6px', textAlign: 'center' }}>
                            <div style={{ fontSize: '11px', color: '#666', marginBottom: '2px' }}>Played</div>
                            <div style={{ fontSize: '18px', fontWeight: 'bold', color: '#333' }}>{diffStats.played}</div>
                          </div>
                          <div style={{ background: '#f5f5f5', padding: '8px', borderRadius: '6px', textAlign: 'center' }}>
                            <div style={{ fontSize: '11px', color: '#666', marginBottom: '2px' }}>Won</div>
                            <div style={{ fontSize: '18px', fontWeight: 'bold', color: '#4CAF50' }}>{diffStats.won}</div>
                          </div>
                          <div style={{ background: '#f5f5f5', padding: '8px', borderRadius: '6px', textAlign: 'center' }}>
                            <div style={{ fontSize: '11px', color: '#666', marginBottom: '2px' }}>Win Rate</div>
                            <div style={{ fontSize: '18px', fontWeight: 'bold', color: '#FF9800' }}>{winRate}%</div>
                          </div>
                        </div>
                        <div style={{ 
                          display: 'grid',
                          gridTemplateColumns: '1fr 1fr',
                          gap: '8px',
                          marginBottom: '15px',
                        }}>
                          <div style={{ background: '#f5f5f5', padding: '8px', borderRadius: '6px', textAlign: 'center' }}>
                            <div style={{ fontSize: '11px', color: '#666', marginBottom: '2px' }}>Best Time</div>
                            <div style={{ fontSize: '18px', fontWeight: 'bold', color: '#2196F3' }}>
                              {diffStats.bestTime ? formatTime(diffStats.bestTime) : 'N/A'}
                            </div>
                          </div>
                          <div style={{ background: '#f5f5f5', padding: '8px', borderRadius: '6px', textAlign: 'center' }}>
                            <div style={{ fontSize: '11px', color: '#666', marginBottom: '2px' }}>Avg Time</div>
                            <div style={{ fontSize: '18px', fontWeight: 'bold', color: '#9C27B0' }}>
                              {diffAvgTime > 0 ? formatTime(diffAvgTime) : 'N/A'}
                            </div>
                          </div>
                        </div>
                        
                        {/* Overall Stats */}
                        <div style={{
                          paddingTop: '12px',
                          borderTop: '2px solid #e0e0e0',
                        }}>
                          <h3 style={{ 
                            marginTop: 0, 
                            marginBottom: '10px', 
                            textAlign: 'center',
                            fontSize: '14px',
                            color: '#666',
                          }}>
                            Overall Stats
                          </h3>
                          <div style={{ 
                            display: 'flex',
                            justifyContent: 'space-around',
                          }}>
                            <div style={{ textAlign: 'center' }}>
                              <div style={{ fontSize: '11px', color: '#666', marginBottom: '2px' }}>Total Games</div>
                              <div style={{ fontSize: '20px', fontWeight: 'bold', color: '#333' }}>{localStats.gamesPlayed}</div>
                            </div>
                            <div style={{ textAlign: 'center' }}>
                              <div style={{ fontSize: '11px', color: '#666', marginBottom: '2px' }}>Total Wins</div>
                              <div style={{ fontSize: '20px', fontWeight: 'bold', color: '#4CAF50' }}>{localStats.gamesWon}</div>
                            </div>
                            <div style={{ textAlign: 'center' }}>
                              <div style={{ fontSize: '11px', color: '#666', marginBottom: '2px' }}>Win Rate</div>
                              <div style={{ fontSize: '20px', fontWeight: 'bold', color: '#FF9800' }}>
                                {localStats.gamesPlayed > 0 ? Math.round((localStats.gamesWon / localStats.gamesPlayed) * 100) : 0}%
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    );
                  })()}
                  
                  <button
                    onClick={() => {
                      // Quit game - return to initial state
                      setGameStarted(false);
                      setGrid([]);
                      setRightSide([]);
                      setSolution([]);
                      setIsComplete(false);
                      setLockedTiles([]);
                      setTileToPosition({});
                      if (timerInterval) {
                        clearInterval(timerInterval);
                        setTimerInterval(null);
                      }
                      setElapsedTime(0);
                      setStartTime(null);
                      setHintsUsed(0);
                    }}
                    style={{
                      width: '100%',
                      padding: '12px',
                      fontSize: '16px',
                      background: '#4CAF50',
                      color: 'white',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: 'pointer',
                      fontWeight: 'bold',
                      boxShadow: '0 4px 12px rgba(76, 175, 80, 0.3)',
                    }}
                  >
                    Return to Puzzle
                  </button>
                </div>
              </div>
            ) : (
              <div
                style={{
                  minHeight: '300px',
                  minWidth: TILE_SIZE + 30,
                }}
              >
                <h2 style={{ textAlign: 'center', marginBottom: '8px', fontSize: '16px' }}>Tiles</h2>
                <div style={{
                  display: 'flex',
                  gap: '10px',
                  background: 'white',
                  padding: '10px',
                  borderRadius: '8px',
                  boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                }}>
                  {/* Always show 5 columns of 5 tiles each (25 total spaces) */}
                  {Array.from({ length: 5 }, (_, colIdx) => (
                    <div key={colIdx} style={{
                      display: 'flex',
                      flexDirection: 'column',
                      gap: '8px',
                    }}>
                      {Array.from({ length: 5 }, (_, rowIdx) => {
                        const tilePosition = colIdx * 5 + rowIdx;
                        const tileIdx = rightSide[tilePosition] !== undefined ? rightSide[tilePosition] : null;
                        
                        if (tileIdx === null) {
                          return (
                            <div
                              key={tilePosition}
                              onDragOver={(e) => e.preventDefault()}
                              onDrop={() => handleDropOnRight(tilePosition)}
                              style={{
                                width: TILE_SIZE,
                                height: TILE_SIZE,
                                background: '#f0f0f0',
                                border: '2px dashed #ccc',
                                borderRadius: '3px',
                              }}
                            />
                          );
                        }
                        
                        return (
                          <div
                            key={tilePosition}
                            draggable
                            onDragStart={() => handleDragStart(tileIdx, { type: 'right', index: tilePosition })}
                            onDragEnd={handleDragEnd}
                            onDragOver={(e) => e.preventDefault()}
                            onDrop={() => handleDropOnRight(tilePosition)}
                          >
                            <Tile 
                              edges={solution[tileIdx]} 
                              size={TILE_SIZE}
                              isDragging={draggedTile === tileIdx}
                            />
                          </div>
                        );
                      })}
                    </div>
                  ))}
                </div>
                
                {/* Information Grid */}
                <div style={{ marginTop: '12px' }}>
                  <h3 style={{ textAlign: 'center', marginBottom: '8px', fontSize: '14px' }}>Available Edges</h3>
                  <table style={{
                    width: '100%',
                    borderCollapse: 'collapse',
                    background: 'white',
                    fontSize: '11px',
                  }}>
                    <thead>
                      <tr>
                        <th style={{ border: '1px solid #ddd', padding: '4px', background: '#f5f5f5' }}></th>
                        <th style={{ border: '1px solid #ddd', padding: '4px', background: 'blue', color: 'white' }}>Blue</th>
                        <th style={{ border: '1px solid #ddd', padding: '4px', background: 'green', color: 'white' }}>Green</th>
                        <th style={{ border: '1px solid #ddd', padding: '4px', background: 'red', color: 'white' }}>Red</th>
                        <th style={{ border: '1px solid #ddd', padding: '4px', background: 'yellow', color: 'black' }}>Yellow</th>
                      </tr>
                    </thead>
                    <tbody>
                      {(() => {
                        const counts = calculateEdgeCounts();
                        return (
                          <>
                            <tr>
                              <td style={{ border: '1px solid #ddd', padding: '4px', fontWeight: 'bold', background: '#f5f5f5' }}>Top</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.top.blue}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.top.green}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.top.red}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.top.yellow}</td>
                            </tr>
                            <tr>
                              <td style={{ border: '1px solid #ddd', padding: '4px', fontWeight: 'bold', background: '#f5f5f5' }}>Bottom</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.bottom.blue}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.bottom.green}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.bottom.red}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.bottom.yellow}</td>
                            </tr>
                            <tr>
                              <td style={{ border: '1px solid #ddd', padding: '4px', fontWeight: 'bold', background: '#f5f5f5' }}>Left</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.left.blue}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.left.green}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.left.red}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.left.yellow}</td>
                            </tr>
                            <tr>
                              <td style={{ border: '1px solid #ddd', padding: '4px', fontWeight: 'bold', background: '#f5f5f5' }}>Right</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.right.blue}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.right.green}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.right.red}</td>
                              <td style={{ border: '1px solid #ddd', padding: '4px', textAlign: 'center' }}>{counts.right.yellow}</td>
                            </tr>
                          </>
                        );
                      })()}
                    </tbody>
                  </table>
                </div>
              </div>
            )}
          </div>
          
          {/* How To Play Dialog */}
          {showHowToPlay && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0,0,0,0.5)',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              zIndex: 1000,
            }}
            onClick={() => setShowHowToPlay(false)}
            >
              <div style={{
                background: 'white',
                padding: '30px',
                borderRadius: '10px',
                maxWidth: '500px',
                boxShadow: '0 4px 20px rgba(0,0,0,0.3)',
              }}
              onClick={(e) => e.stopPropagation()}
              >
                <h2 style={{ marginTop: 0, marginBottom: '20px' }}>How To Play</h2>
                <p style={{ lineHeight: '1.6', marginBottom: '15px' }}>
                  Place tiles where the colors match. Use the Hint if you need help. Use Clear to remove all unlocked tiles and try again (locked tiles and timer remain).
                </p>
                <p style={{ lineHeight: '1.6', marginBottom: '15px' }}>
                  Easy mode starts you out with a number of locked tiles. Medium mode gives you fewer locked tiles and Hard mode starts you with even fewer. Extreme mode has the fewest locked tiles.
                </p>
                <p style={{ lineHeight: '1.6', marginBottom: '20px' }}>
                  <strong>Note:</strong> Hint will place a tile in the correct place if one is available. That does not mean the unlocked tiles around it are necessarily correct!
                </p>
                <button
                  onClick={() => setShowHowToPlay(false)}
                  style={{
                    width: '100%',
                    padding: '12px',
                    fontSize: '16px',
                    background: '#4CAF50',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  Got It!
                </button>
              </div>
            </div>
          )}
          
          {/* Stats Dialog */}
          {showStats && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0,0,0,0.5)',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              zIndex: 1000,
            }}
            onClick={() => setShowStats(false)}
            >
              <div style={{
                background: 'white',
                padding: '30px',
                borderRadius: '10px',
                maxWidth: '500px',
                boxShadow: '0 4px 20px rgba(0,0,0,0.3)',
              }}
              onClick={(e) => e.stopPropagation()}
              >
                <h2 style={{ marginTop: 0, marginBottom: '20px' }}>Statistics</h2>
                
                {(() => {
                  const localStats = getLocalStats();
                  const avgTime = localStats.gamesWon > 0 
                    ? Math.round(localStats.totalTime / localStats.gamesWon) 
                    : 0;
                  
                  return (
                    <>
                      <h3 style={{ marginTop: 0, marginBottom: '10px', fontSize: '16px' }}>Your Stats</h3>
                      <div style={{ marginBottom: '20px', lineHeight: '1.8' }}>
                        <div><strong>Games Played:</strong> {localStats.gamesPlayed}</div>
                        <div><strong>Games Won:</strong> {localStats.gamesWon}</div>
                        <div><strong>Win Rate:</strong> {localStats.gamesPlayed > 0 ? Math.round((localStats.gamesWon / localStats.gamesPlayed) * 100) : 0}%</div>
                        <div><strong>Best Time:</strong> {localStats.bestTime ? formatTime(localStats.bestTime) : 'N/A'}</div>
                        <div><strong>Average Time:</strong> {avgTime > 0 ? formatTime(avgTime) : 'N/A'}</div>
                      </div>
                      
                      <h3 style={{ marginTop: 0, marginBottom: '10px', fontSize: '16px' }}>By Difficulty</h3>
                      <div style={{ marginBottom: '20px', lineHeight: '1.8', fontSize: '14px' }}>
                        {['easy', 'medium', 'hard', 'extreme'].map(diff => {
                          const stats = localStats.statsByDifficulty[diff];
                          const winRate = stats.played > 0 ? Math.round((stats.won / stats.played) * 100) : 0;
                          return (
                            <div key={diff} style={{ marginBottom: '8px' }}>
                              <strong style={{ textTransform: 'capitalize' }}>{diff}:</strong> {stats.played} played, {stats.won} won ({winRate}%)
                            </div>
                          );
                        })}
                      </div>
                      
                      <h3 style={{ marginTop: 0, marginBottom: '10px', fontSize: '16px' }}>Global Stats</h3>
                      {globalStats ? (
                        <div style={{ marginBottom: '20px', lineHeight: '1.8' }}>
                          <div><strong>Total Games Started:</strong> {globalStats.totalGamesStarted}</div>
                          <div><strong>Total Games Won:</strong> {globalStats.totalGamesWon}</div>
                          <div><strong>Global Win Rate:</strong> {globalStats.totalGamesStarted > 0 ? Math.round((globalStats.totalGamesWon / globalStats.totalGamesStarted) * 100) : 0}%</div>
                          <div><strong>Global Avg Time:</strong> {globalStats.averageTime > 0 ? formatTime(globalStats.averageTime) : 'N/A'}</div>
                        </div>
                      ) : (
                        <div style={{ marginBottom: '20px', fontStyle: 'italic' }}>Loading global stats...</div>
                      )}
                    </>
                  );
                })()}
                
                <button
                  onClick={() => setShowStats(false)}
                  style={{
                    width: '100%',
                    padding: '12px',
                    fontSize: '16px',
                    background: '#4CAF50',
                    color: 'white',
                    border: 'none',
                    borderRadius: '5px',
                    cursor: 'pointer',
                    fontWeight: 'bold',
                  }}
                >
                  Close
                </button>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<GridBuilder />, document.getElementById('root'));
  </script>
</body>
</html>
